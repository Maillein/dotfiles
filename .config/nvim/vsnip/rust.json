{
    "matrix": {
        "prefix": "matrix",
        "body": [
            "#[allow(unused_macros)]",
            "macro_rules! mat {",
            "    (\\$(\\$e:expr),*) => { Vec::from(vec![\\$(\\$e),*]) };",
            "    (\\$(\\$e:expr,)*) => { Vec::from(vec![\\$(\\$e),*]) };",
            "    (\\$e:expr; \\$d:expr) => { Vec::from(vec![\\$e; \\$d]) };",
            "    (\\$e:expr; \\$d:expr \\$(; \\$ds:expr)+) => { Vec::from(vec![mat![\\$e \\$(; \\$ds)*]; \\$d]) };",
            "}"
        ],
        "description": ""
    },

    "debug": {
        "prefix": "debug",
        "body": [
            "#[allow(unused_macros)]",
            "macro_rules! debug {",
            "    (\\$(\\$a:expr),* \\$(,)*) => {",
            "        #[cfg(debug_assertions)]",
            "        eprintln!(concat!(\\$(\"| \", stringify!(\\$a), \"={:?} \"),*, \"|\"), \\$(&\\$a),*);",
            "    };",
            "}"
        ],
        "description": "デバック用マクロ"
    },

    "shotest_path": {
        "prefix": "shotest_path",
        "body": [
            "fn shotest_path(edges: &Vec<Vec<(usize, usize)>>, start: usize) -> Vec<usize> {",
            "    let mut dist = vec![1usize << 60; edges.len()];",
            "    let mut heap = BinaryHeap::new();",
            "",
            "    dist[start] = 0;",
            "    heap.push( (Reverse(0), start) );",
            "    while let Some( (Reverse(cost), pos) ) = heap.pop() {",
            "        if cost > dist[pos] { continue; }",
            "",
            "        for &(n_pos, n_cost) in &edges[pos] {",
            "            if cost + n_cost < dist[n_pos] {",
            "                dist[n_pos] = cost + n_cost;",
            "                heap.push( (Reverse(cost + n_cost), n_pos) );",
            "            }",
            "        }",
            "    }",
            "",
            "    dist",
            "}"
        ],
        "description": "ダイクストラ法"
    },

    "yesno": {
        "prefix": "yesno",
        "body": [
            "if ${1:cond} {",
            "    println!(\"Yes\");",
            "} else {",
            "    println!(\"No\");",
            "}"
        ],
        "description": "Yes/Noを出力"
    },

    "printv": {
        "prefix": "printv",
        "body": [
            "println!(\"{}\", $1);$2"
        ],
        "description": "値を出力"
    },

    "modfunc": {
        "prefix": "modfunc",
        "body": [
            "fn mod_pow(r: usize, mut n: usize) -> usize {",
            "    let mut t = 1;",
            "    let mut s = r % MOD;",
            "    while n > 0 {",
            "        if n & 1 == 1 {",
            "            t = t * s % MOD;",
            "        }",
            "        s = s * s % MOD;",
            "        n >>= 1;",
            "    }",
            "    t",
            "}",
            "",
            "fn mod_inv(x: usize) -> usize {",
            "    mod_pow(x, MOD - 2)",
            "}",
            "",
            "fn mod_conv(n: usize, k: usize) -> usize {",
            "    let k = std::cmp::min(k, n - k);",
            "    let mut nu = 1;",
            "    let mut de = 1;",
            "    for i in 0..k {",
            "        nu = nu * (n - i) % MOD;",
            "        de = de * (i + 1) % MOD;",
            "    }",
            "    nu * mod_inv(de) % MOD",
            "}",
            "fn mod_fact(x: usize) -> usize {",
            "    let mut r = 1usize;",
            "    for i in 2..=x {",
            "        r *= i;",
            "        r %= MOD;",
            "    }",
            "    r",
            "}"
        ],
        "description": "階乗，累乗、逆元、コンビネーションを計算"
    },

    "combination": {
        "prefix": "combination",
        "body": [
            "const COM_TABLE_SIZE: usize = 5_000_001;",
            "struct COM {",
            "    fact_table: Vec<usize>,",
            "    inv_table: Vec<usize>,",
            "    finv_table: Vec<usize>,",
            "}",
            "",
            "impl COM {",
            "    fn new() -> Self {",
            "        let mut fact_table = vec![1usize; COM_TABLE_SIZE];",
            "        let mut inv_table = vec![1usize; COM_TABLE_SIZE];",
            "        let mut finv_table = vec![1usize; COM_TABLE_SIZE];",
            "        for i in 2..COM_TABLE_SIZE {",
            "            fact_table[i] = fact_table[i - 1] * i % MOD;",
            "            inv_table[i] = MOD - inv_table[MOD % i] * (MOD / i) % MOD;",
            "            finv_table[i] = finv_table[i - 1] * inv_table[i] % MOD;",
            "        }",
            "        Self {",
            "            fact_table,",
            "            inv_table,",
            "            finv_table,",
            "        }",
            "    }",
            "",
            "    fn comb(&self, n: usize, k: usize) -> usize {",
            "        if n < k {",
            "            0",
            "        } else {",
            "            self.fact_table[n] * (self.finv_table[k] * self.finv_table[n - k] % MOD) % MOD",
            "        }",
            "    }",
            "}"
        ],
        "description": "事前計算を行い、高速にnCkを求める。(ex: let com = COM::new(); com.comb(5, 2);)"
    },
    "combsmall": {
        "prefix": "combsmall",
        "body": [
            "const COM_SMALL_TABLE_SIZE: usize = 61;",
            "",
            "struct ConbSmall {",
            "    tbl: Vec<Vec<usize>>,",
            "}",
            "impl ConbSmall {",
            "    fn new() -> Self {",
            "        let mut tbl = vec![vec![0; COM_SMALL_TABLE_SIZE]; COM_SMALL_TABLE_SIZE];",
            "        let n = tbl.len();",
            "        for i in 0..n {",
            "            tbl[i][0] = 1;",
            "            tbl[i][i] = 1;",
            "        }",
            "",
            "        for i in 1..n {",
            "            for j in 1..i {",
            "                tbl[i][j] = tbl[i - 1][j] + tbl[i - 1][j - 1];",
            "            }",
            "        }",
            "",
            "        ConbSmall { tbl }",
            "    }",
            "",
            "    fn comb(&self, n: usize, r: usize) -> usize {",
            "        if n < r {",
            "            0",
            "        } else {",
            "            self.tbl[n][r]",
            "        }",
            "    }",
            "}"
        ],
        "description": ""
    }
}
