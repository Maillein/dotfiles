{
    "atcoder": {
        "prefix": "atcoder",
        "body": [
            "#![allow(unused_imports, dead_code, non_snake_case)]",
            "",
            "// {{{ use",
            "use itertools::Itertools;",
            "use num::{",
            "    abs,",
            "    integer::{gcd, lcm, Roots},",
            "    pow, range_step, range_step_inclusive,",
            "};",
            "use petgraph::{",
            "    algo::{bellman_ford, dijkstra},",
            "    graph::{node_index, DiGraph, UnGraph},",
            "    unionfind::UnionFind,",
            "    visit::{depth_first_search, DfsEvent},",
            "};",
            "use proconio::{",
            "    input,",
            "    marker::{Bytes, Chars, Usize1},",
            "};",
            "use std::cmp::{max, min, Ordering, Reverse};",
            "use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};",
            "use std::mem::swap;",
            "use superslice::Ext;",
            "// }}}",
            "",
            "// {{{ const",
            "const MOD: usize = 1_000_000_007;",
            "// const MOD: usize = 998_244_353;",
            "const XY2: [(i64, i64); 2] = [(0, 1), (1, 0)];",
            "const XY4: [(i64, i64); 4] = [(1, 0), (0, 1), (-1, 0), (0, -1)];",
            "const XY8: [(i64, i64); 8] = [",
            "    (1, 0),",
            "    (1, 1),",
            "    (0, 1),",
            "    (-1, 1),",
            "    (-1, 0),",
            "    (-1, -1),",
            "    (0, -1),",
            "    (1, -1),",
            "];",
            "// }}}",
            "",
            "// {{{ macro",
            "#[allow(unused_macros)]",
            "macro_rules! debug {",
            "    (\\$(\\$a:expr),* \\$(,)*) => {",
            "        #[cfg(debug_assertions)]",
            "        eprintln!(concat!(\\$(\"| \", stringify!(\\$a), \"={:?} \"),*, \"|\"), \\$(&\\$a),*);",
            "    };",
            "}",
            "",
            "#[allow(unused_macros)]",
            "macro_rules! chmin {",
            "    (\\$base:expr, \\$(\\$cmps:expr),+ \\$(,)*) => {{",
            "        let cmp_min = my_min!(\\$(\\$cmps),+);",
            "        if \\$base > cmp_min {",
            "            \\$base = cmp_min;",
            "            true",
            "        } else {",
            "            false",
            "        }",
            "    }};",
            "}",
            "",
            "#[allow(unused_macros)]",
            "macro_rules! chmax {",
            "    (\\$base:expr, \\$(\\$cmps:expr),+ \\$(,)*) => {{",
            "        let cmp_max = my_max!(\\$(\\$cmps),+);",
            "        if \\$base < cmp_max {",
            "            \\$base = cmp_max;",
            "            true",
            "        } else {",
            "            false",
            "        }",
            "    }};",
            "}",
            "",
            "#[allow(unused_macros)]",
            "macro_rules! my_min {",
            "    (\\$a:expr \\$(,)*) => {{",
            "        \\$a",
            "    }};",
            "    (\\$a:expr, \\$b:expr \\$(,)*) => {{",
            "        std::cmp::min(\\$a, \\$b)",
            "    }};",
            "    (\\$a:expr, \\$(\\$rest:expr),+ \\$(,)*) => {{",
            "        std::cmp::min(\\$a, my_min!(\\$(\\$rest),+))",
            "    }};",
            "}",
            "",
            "#[allow(unused_macros)]",
            "macro_rules! my_max {",
            "    (\\$a:expr \\$(,)*) => {{",
            "        \\$a",
            "    }};",
            "    (\\$a:expr, \\$b:expr \\$(,)*) => {{",
            "        std::cmp::max(\\$a, \\$b)",
            "    }};",
            "    (\\$a:expr, \\$(\\$rest:expr),+ \\$(,)*) => {{",
            "        std::cmp::max(\\$a, my_max!(\\$(\\$rest),+))",
            "    }};",
            "}",
            "// }}}",
            "",
            "fn main() {",
            "    input! {",
            "        $1",
            "    }",
            "    $2",
            "}"
        ],
        "description": "AtCoder用テンプレート"
    },

    "debug": {
        "prefix": "debug",
        "body": [
            "#[allow(unused_macros)]",
            "macro_rules! debug {",
            "    (\\$(\\$a:expr),* \\$(,)*) => {",
            "        #[cfg(debug_assertions)]",
            "        eprintln!(concat!(\\$(\"| \", stringify!(\\$a), \"={:?} \"),*, \"|\"), \\$(&\\$a),*);",
            "    };",
            "}"
        ],
        "description": "デバック用マクロ"
    },

    "shotest_path": {
        "prefix": "shotest_path",
        "body": [
            "fn shotest_path(edges: &Vec<Vec<(usize, usize)>>, start: usize) -> Vec<usize> {",
            "    let mut dist = vec![1usize << 60; edges.len()];",
            "    let mut heap = BinaryHeap::new();",
            "",
            "    dist[start] = 0;",
            "    heap.push( (Reverse(0), start) );",
            "    while let Some( (Reverse(cost), pos) ) = heap.pop() {",
            "        if cost > dist[pos] { continue; }",
            "",
            "        for &(n_pos, n_cost) in &edges[pos] {",
            "            if cost + n_cost < dist[n_pos] {",
            "                dist[n_pos] = cost + n_cost;",
            "                heap.push( (Reverse(cost + n_cost), n_pos) );",
            "            }",
            "        }",
            "    }",
            "",
            "    dist",
            "}"
        ],
        "description": "ダイクストラ法"
    },

    "yesno": {
        "prefix": "yesno",
        "body": [
            "if ${1:cond} {",
            "    println!(\"Yes\");",
            "} else {",
            "    println!(\"No\");",
            "}"
        ],
        "description": "Yes/Noを出力"
    },

    "printv": {
        "prefix": "printv",
        "body": [
            "println!(\"{}\", $1);$2"
        ],
        "description": "値を出力"
    },

    "modfunc": {
        "prefix": "modfunc",
        "body": [
            "fn mod_pow(r: usize, mut n: usize) -> usize {",
            "    let mut t = 1;",
            "    let mut s = r % MOD;",
            "    while n > 0 {",
            "        if n & 1 == 1 {",
            "            t = t * s % MOD;",
            "        }",
            "        s = s * s % MOD;",
            "        n >>= 1;",
            "    }",
            "    t",
            "}",
            "",
            "fn mod_inv(x: usize) -> usize {",
            "    mod_pow(x, MOD - 2)",
            "}",
            "",
            "fn mod_conv(n: usize, k: usize) -> usize {",
            "    let k = std::cmp::min(k, n - k);",
            "    let mut nu = 1;",
            "    let mut de = 1;",
            "    for i in 0..k {",
            "        nu = nu * (n - i) % MOD;",
            "        de = de * (i + 1) % MOD;",
            "    }",
            "    nu * mod_inv(de) % MOD",
            "}"
        ],
        "description": "累乗、逆元、コンビネーションを計算"
    },

    "combination": {
        "prefix": "combination",
        "body": [
            "const COM_TABLE_SIZE: usize = 5_000_001;",
            "struct COM {",
            "    fact_table: Vec<usize>,",
            "    inv_table: Vec<usize>,",
            "    finv_table: Vec<usize>,",
            "}",
            "",
            "impl COM {",
            "    fn new() -> Self {",
            "        let mut fact_table = vec![1usize; COM_TABLE_SIZE];",
            "        let mut inv_table = vec![1usize; COM_TABLE_SIZE];",
            "        let mut finv_table = vec![1usize; COM_TABLE_SIZE];",
            "        for i in 2..COM_TABLE_SIZE {",
            "            fact_table[i] = fact_table[i - 1] * i % MOD;",
            "            inv_table[i] = MOD - inv_table[MOD % i] * (MOD / i) % MOD;",
            "            finv_table[i] = finv_table[i - 1] * inv_table[i] % MOD;",
            "        }",
            "        Self {",
            "            fact_table,",
            "            inv_table,",
            "            finv_table,",
            "        }",
            "    }",
            "",
            "    fn comb(&self, n: usize, k: usize) -> usize {",
            "        if n < k {",
            "            0",
            "        } else {",
            "            self.fact_table[n] * (self.finv_table[k] * self.finv_table[n - k] % MOD) % MOD",
            "        }",
            "    }",
            "}"
        ],
        "description": "事前計算を行い、高速にnCkを求める。(ex: let com = COM::new(); com.comb(5, 2);)"
    }
}
